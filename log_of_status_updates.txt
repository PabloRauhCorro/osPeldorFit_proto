6.2.2021:	I rewrote the methods effective_g, effective_A, line_broadening and calculate_spectrum. The for loops with nfields iterations were replaced
			with operations on numpy arrays. For example, instead of returning a single gValue for one single field direction, effective_g_array() returns
			an array of size nfields containing all the gValues for every field direction. This led to a significant speed up. Calculation of spectrum now
			takes around half a second, used to take 15+ seconds.

			Problems: 
			1) Spectrum still doesn't look like the C++ version. It just looks like a gauss curve
			2) Once in about 7 times calculate spectrum throws an error. I suspect that the cause might be that I don't use random distributions/rngs
			correctly. Need to talk with Dinar about seeding and what urng does in C++ Peldor.

11.2.2021:	1) The program architecture was extended. 
			2) The read_config method was extended. 
			3) The Spin class was rewritten. 
			4) The Simulator class was modified: 
				a) The epr_spectrum attribute was added. It allows to correctly compute the EPR spectrum (tested by means of main_test.py) 
				b) The attribute peldor_signal and several others were temporaly removed, because they need to be rewritten by using a more general class Experiment.
				c) The class Peldor_4p_rect was implemented (not completed).

21.2.2021:	1) The simulation of the time trace was implemented in the method compute_time_trace() in peldor_4p_rect.py.
			It is currently limited to a unimodal, two spin spin system. The old C++ code was used as a template. Instead of looping
			over the monte carlo sample size, the computations are based (almost) entirely on numpy arrays. The timetrace was plotted
			and looks correct at first glance. The calculation takes around 15 seconds.
			2) Instead of using the script rotation_matrix.py, compute_time_trace() uses the equivalent scipy functionality.
			The script and the scipy method were tested and compared. They produce the same rotation matrix.
			3) Problems: 
				- pump efficiency is a value that is needed for calculating the timetrace and it is not in cfg file.
				I simply set it to 0.9 for now.

				- I am very unsure about how to properly use the pump and detection probabilities. They have the shape
				(mc_size, 3), however following the C++ PeldorFit logic they should have (mc_size, ). I used the max value of
				each triple/subarray to reshape them into (mc_size, ). This is most likely not correct

				- attempts to vectorize the for loop at line 118 in peldor_4p_rect.py led to very large arrays. This remaining for loop
				takes 10 seconds. There is probably a more clever way to do this.

			4) next step: write a proper plot method for timetrace and compare the timetrace to C++ PeldorFit timetrace

01.03.2021:	1) The config file was extended: variables 'experiment.mixing_time', 'spin.T1', 'spin.g_anisotropy_in_dipolar_coupling' were added.
			2) The read_config method was changed accordingly to 1). 
			3) The Spin.res_freq method's output was changed. 
			4) The Peldor_4p_rect.compute_time_trace method was removed.
			5) The Ridme_5p_rect class was created and included in experiment_types.
			6) The Simulator class was modified: Many new methods were added. Among these, a 'compute_time_trace_via_monte_carlo' method, which allows to calculate a 
			   time trace via Monte-Carlo integration. Currently, this method is limited by 2 spins and the assumption that the g-anisopropy of both spins have a negligible
               effect on the dipolar coupling frequencies calculated.
			   The 'compute_time_trace_via_grids' method, which allows to calculate a time trace via integration grids, was also initialized and needs to be implemented in future.

04.03.2021:	1) The config file was extended: variables 'calculation_settings.fit_modulation_depth' and 'calculation_settings.interval_modulation_depth' were added to 
			enable/disable re-scaling of the modulation depths of simulated PDS time traces in accordance to the experimental PDS time traces.
			2) The read_config and experiment methods were changed accordingly to 1). 
			3) New methods were added to the Simulator class: 
				'compute_time_traces' - to simulate all eperimental PDS time traces at ones,
				'epr_spectra' - to simulate the EPR spectrum of a spin system at multiple magnetic fields,
				'bandwidths' - to compute the bandwidths of detection and pump pulses in all experiments
			4) New plotting methods were developed, e.g. 'plot_bandwidths', 'plot_grids', and 'plot_time_traces'.
			5) New output methods were developed, e.g. 'save_bandwidths' and 'save_time_traces'.
			6) Special focus was laid on formating the code.
			7) IMPORTANT: Each attribute of the class and each function has to have a short description in the following form:
				def compute_time_trace_via_monte_carlo(self, experiment, spins, variables):
					''' Computes a PDS time trace via Monte-Carlo integration '''
				... code ...

09.03.2021:	1) Simulator class was updated:
				a) The method 'precalculations' was added. It allows to pre-compute 'field_orientations', 'effective_gfactors_spin1', 
				'detection_probabilities_spin1' and 'pump_probabilities_spin1' for spin #1. This will save computation time during 
				the fitting.
				b) The method 'compute_time_trace_via_monte_carlo' was extended to anisotropic spin centers. Now, one has
				four options for the spin pair: 
					I) spins 1 and 2 have almost isotropic g-factors
					II) spins 1 has an almost isotropic g-factor, spin 2 has an anisotropic g-factor
					III) spins 2 has an almost isotropic g-factor, spin 1 has an anisotropic g-factor
					IV) spins 1 and 2 have anisotropic g-factors 
				c) The method 'compute_time_trace' was extended to the multi-spin (number of spins > 2) case.
				d) To allow c), a new method called 'compute_time_trace_via_monte_carlo_multispin' was developed.
				e) The possibility to match the modulation depths of the experimental and simulated time traces was added to 
				the 'compute_time_trace' method. It is implemented via a new method called 'rescale_modulation_depth'.
				f) The methods 'set_r_orientations' and 'set_spin_frame_rotations' were rewritten. The sine-weights were
				deprecated and, instead, a random generator with an arbitrary distribution function was implemented (see point 2)).
			
			2) The methods in 'random_points_from_distribution' and 'distributions' were extended and allow now to generate random points 
			from uniform/normal/von Mises (unimodal or multimodal) distributions or sine-weighted uniform/normal/von Mises 
			(unimodal or multimodal) distributions.	
			
			3) To support 1b, the Spin class was extended with a method called 'quantization_axis'.
			
			4) Some plot methods were updated to make the generated figures look nicer.
			
			5) The examples folder was updated. Now we have four examples:
				a) nitroxide_biradical_Wband_PELDOR:
					- PELDOR experiment
					- 2 spins: nitroxide & nitroxide
					- both nitroxide spins have an almost isotropic g-factor
					- unimodal distance and angle distributions
				b) azurin_t21r1_Xband_PELDOR
					- PELDOR experiment
					- 2 spins: nitroxide & Cu(II)
					- both spins have an almost isotropic g-factor
					- bimodal distance and angle distributions (2 conformations of the nitrixide spin label)
				c) lowspin_iron_trityl_Qband_RIDME:
					- RIDME experiment
					- 2 spins: nitroxide & low-spin Fe(III)
					- nitroxide spin have an almost isotropic g-factor, low-spin Fe(III) has an anisotropic g-factor
					- unimodal distance and angle distributions
				d) copper_trinuclear_Xband_PELDOR
					- PELDOR experiment
					- 3 spins: Cu(II) & Cu(II) & Cu(II)
					- all Cu(II) spins have an almost isotropic g-factor
					- unimodal distance and angle distributions for each spin pair
				
				