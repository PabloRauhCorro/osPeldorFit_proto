6.2.2021: I rewrote the methods effective_g, effective_A, line_broadening and calculate_spectrum. The for loops with nfields iterations were replaced
	  with operations on numpy arrays. For example, instead of returning a single gValue for one single field direction, effective_g_array() returns
	  an array of size nfields containing all the gValues for every field direction. This led to a significant speed up. Calculation of spectrum now
	  takes around half a second, used to take 15+ seconds

	  Problems: 1) Spectrum still doesn't look like the C++ version. It just looks like a gauss curve
                    2) Once in about 7 times calculate spectrum throws an error. I suspect that the cause might be that I don't use random distributions/rngs
		       correctly. Need to talk with Dinar about seeding and what urng does in C++ Peldor.
--------------------------------------------------------------------------------------------

11.2.2021: 1) The program architecture was extended. 
           2) The read_config method was extended. 
	   3) The Spin class was rewritten. 
	   4) The Simulator class was modified: 
      	   	a) The epr_spectrum attribute was added. It allows to correctly compute the EPR spectrum (tested by means of main_test.py) 
	  	b) The attribute peldor_signal and several others were temporaly removed, because they need to be rewritten by using a more general class Experiment.
	  	c) The class Peldor_4p_rect was implemented (not completed).

--------------------------------------------------------------------------------------

21.2.2021 : 1) The simulation of the time trace was implemented in the method compute_time_trace() in peldor_4p_rect.py.
		It is currently limited to a unimodal, two spin spin system. The old C++ code was used as a template. Instead of looping
		over the monte carlo sample size, the computations are based (almost) entirely on numpy arrays. The timetrace was plotted
		and looks correct at first glance. The calculation takes around 15 seconds.

		2) Instead of using the script rotation_matrix.py, compute_time_trace() uses the equivalent scipy functionality.
		The script and the scipy method were tested and compared. They produce the same rotation matrix.

		3) Problems: - pump efficiency is a value that is needed for calculating the timetrace and it is not in cfg file.
			       I simply set it to 0.9 for now.

			 - I am very unsure about how to properly use the pump and detection probabilities. They have the shape
			   (mc_size, 3), however following the C++ PeldorFit logic they should have (mc_size, ). I used the max value of
			   each triple/subarray to reshape them into (mc_size, ). This is most likely not correct

			 - attempts to vectorize the for loop at line 118 in peldor_4p_rect.py led to very large arrays. This remaining for loop
			   takes 10 seconds. There is probably a more clever way to do this.

-------------------------------------------------------------------------------------------

28.2.2021  1) Minor changes:
			 - simulator.py: The name of the method field_orientations() was changed to set_field_directions() 
				due to a name clash with the variable field_orientations
			 - peldor_4p_rect.py: changes were made to detection and pump probability because weighting was not compatible
			   with the method class from pump_bandwidth() and detection_bandwith(). Need to discuss
			 - moved simulate_time_trace() into the class Simulator
